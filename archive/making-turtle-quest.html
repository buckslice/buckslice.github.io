<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="/icons/planet.ico">

    <title>The Making of Turtle Quest</title>

	<link href="/mystyle.css" rel="stylesheet">
	
	<link href="/libs/prism.css" rel="stylesheet">
	
<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-TC4FMXD');</script>
<!-- End Google Tag Manager -->

	
  </head>

  <body>
  <!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-TC4FMXD"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
  	<div id="nav"><ul>
		<li><a href="/games.html">Games</a></li>
		<li><a href="/projects.html">Projects</a></li>
		<li><a href="/archive.html">Archive</a></li>
		<li><a href="/resume.pdf">Resume</a></li>
		<li class="rightFloat"><a href="/about.html">About</a></li>
	</ul></div>
  	<div class="content">
	
	<h1>
		The Making of Turtle Quest
	</h1>
	<h3 style="color:#FF0000">THIS ARTICLE IS A WORK IN PROGRESS</h3>
		<h3 style="color:#FF0000">(IM GONA ADD PICTURES DONT WORRY)</h3>
	<br><br>
	<img src="/img/turtleQuest.png" alt="">
	
	<p>
	In this post I will talk about how me and my friend Jeffrey made TurtleQuest over the course of the weekend (Jan 25th-27th 2019) for the Global Game Jam. As the event began we tried to get into a group with an artist and failed (again as we do every year lol). So we ended up just doing a two man group and had to fend for ourselves on the art side. Not to worry, this wasn't are first rodeo lol.
	</p>
	<p>
	We decide to take on the Assetless diversifier (no traditional art assets allowed), so the visuals of TurtleQuest were all procedurally generated or done with shaders. The only exceptions were we used scaled Unity primitives for the turtle, shark and trash, and we used a particle system for the jellyfish (only with the unity default particle though so still counts hiyeahh).
	</p>
	<p>
	First I will explain the basis of pretty much all the art in this game.
	</p>
	
	<h2>Talkin' bout NOISE</h2>
	
	<p>Okay so basically the game uses procedural noise for all of the art. From the textures on every object, to the shape of the terrain/rocks/coral/kelp, to the rippling water refraction effect. Its all noise babeyyyy. Before I kind of try to explain what noise is please just check out these two links (at least the first one)<br>
	<a class="link" href="https://thebookofshaders.com/11/">The book of shaders: Noise</a><br>
	<a class="link" href="https://thebookofshaders.com/13/">The book of shaders: Fractal Brownian Motion</a>
	</p>
	
	<p>
	That whole site is pretty cash money if you are interested in shaders and they explain everything really smartly (just like me does hurhurrhur).
	</p>
	
	<p>I'll try to add my own layman's explanation. A good thought to take away from those articles 'noise is smooth randomness'. So when you think about the difference between a random number function vs a noise function, random functions have no arguments (or if they do its usually providing a range), while with noise functions you have to give a coordinate into the space you are sampling. Either 1D, 2D, 3D, or even 4D coordinates depending on what specific noise function or library you are using. The end returns of noise functions are going to be singular float values (usually in a range -1 to 1 or 0 to 1), but the kicker is that nearby sampled values will have similar results to eachother. And the functions know about this because of the coordinate you are passing to them. This smooth continuity is what allows much more complex and rich effects to be created as oppose to simply random values.
	</p>
	
	<p>
	Another good thing to takeaway is that theres tons of different ways to tweak, combine, and experiment with your noise functions and related code. The main way I learned is just trying random stuff and seeing what happens. Eventually you kind of get a vague idea on what parameters to change first so you can become a fast badboy. Additionally when learning its great to test noise in shaders because you don't even have to stop the game to see the changes as shaders can recompile while the games running!
	</p>
	
	<p>So over the years (eww) I have accumulated and modified different noise functions I found and packaged them into two files. The first is a csharp file, 
	
	<a class="link" href="https://github.com/buckslice/turtle-quest/blob/master/Assets/Terrain/Noise.cs">Noise.cs</a>,
	
	this is what I used for the terrain, rock, and coral generation so that way I could generate the meshes once and upload it to GPU. The second file is a shader include file,
	
	<a class="link" href="https://github.com/buckslice/turtle-quest/blob/master/Assets/Shaders/Includes/Noise.cginc">Noise.cginc</a>.
	
	That's how I did all the texture effects, water refraction effect, and kelp rippling vertex displacement. So depending on where you need the noise you use either file. Just make sure to #include "Assets/path/to/Noise.cginc" in your shaders if you use that one.	
	</p>
	
	<h2>Terrain Generation</h2>
	
	<p>
	I made code that generates a grid mesh in the xz plane and then offset it on the y based on noise generation. Hopefully you read the second link about fractal brownian motion as well. Here is the fbm function.
	</p>
	
	<pre><code class="language-csharp">float fbm(float3 x, int octaves, float frequency, float persistence, float lacunarity) {
    float sum = 0.0;
    float amplitude = 1.0;
    for (int i = 0; i < octaves; i++) {
        sum += snoise(x * frequency) * amplitude;
        amplitude *= persistence;
        frequency *= lacunarity;
    }
    return sum;
}</code></pre>

	<h2>Rock/Coral Generation</h2>
	
	<p>
	Talk about icospheres! vertex displacement (not in shader though)
	</p>
	
	
	<h2>Refraction Effect</h2>
	<p>
	For the underwater refraction effect, I just wrote an extra ripple function in Noise.cginc file (that all shaders were using) so at the end of their surf function they could all just add on this line to add the water refraction effect.
	</p>
	
	<pre><code class="language-csharp">o.Albedo *= ripples(IN.worldPos);</code></pre>
	
	<p>
	It is using the built in shader parameter 'worldPos' so the effect is continous over all the objects that use it. If you used regular vertex position it would've been in object space so wouldn't be continuous over the whole scene. Now here is the ripples function.
	</p>
	
	<pre><code class="language-csharp">float3 ripples(float3 wp) {
    return 0.5 + 0.5 * (worley(wp + float3(_Time.x * 7, _Time.x * 17, -_Time.x * 30), 3, .5, 0.5, 2.0, .5, 3.5));    
}</code></pre>

	<p>
	So what this is doing is basically ____ todo: explain this garbage lol
	</p>
	
	<p>	
	In hindsight it would probably be more performant to just use a scrolling light cookie texture so refraction shadows are cast via the light instead, but I wasn't sure how to make a scrolling texture through code and the ripple function was super easy to just add to every shader.
	</p>
	
	</div>
	<footer>
Copyright ©️ John F. Collins III 2019
	</footer>
	
	<script src="/libs/prism.js"></script>
  </body>
</html>
