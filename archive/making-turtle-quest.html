<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="icon" href="/icons/planet.ico">

    <title>The Making of Turtle Quest</title>

	<link href="/mystyle.css" rel="stylesheet">
	
	<link href="/libs/prism.css" rel="stylesheet">
	
<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-TC4FMXD');</script>
<!-- End Google Tag Manager -->

	
  </head>

  <body>
  <!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-TC4FMXD"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) -->
  	<div id="nav"><ul>
		<li><a href="/games.html">Games</a></li>
		<li><a href="/projects.html">Projects</a></li>
		<li><a href="/archive.html">Archive</a></li>
		<li><a href="/resume.pdf">Resume</a></li>
		<li class="rightFloat"><a href="/about.html">About</a></li>
	</ul></div>
  	<div class="content">
	
	<h1>
		The Making of Turtle Quest
	</h1>
	
	<h3 style="color:#FF0000">THIS ARTICLE IS A WORK IN PROGRESS</h3>
		<h3 style="color:#FF0000">(IM GONA ADD MORE PICTURES DONT WORRY)</h3>
	<br>
	
	<img src="/img/turtleQuest.png" alt="">
	
	<p>
	In this post I will talk about how my friend Jeffrey and I made TurtleQuest over the course of the weekend (Jan 25th-27th 2019) for the Global Game Jam. As the event began we tried to get into a group with an artist and failed (again as we do every year lol). So we ended up just doing a two man group and had to fend for ourselves on the art side. Not to worry, this wasn't are first rodeo lol.
	</p>
	<p>
	We decided to take on the Assetless diversifier (no traditional art assets allowed), so the visuals of TurtleQuest were all procedurally generated or done with shader programs. The only exceptions were we used scaled Unity primitives for the turtle, shark and trash, and we used a particle system for the jellyfish (only with the unity default particle though so still counts??? hiyeahh).
	</p>
	<h2>Talkin' bout NOISE</h2>
	
	<p>Turtle Quest uses procedural noise for pretty much all of the art. From the textures on every object, to the shape of the terrain/rocks/coral/kelp, to the rippling water refraction effect. Its all noise babeyyyy.
	</p>
	
	<p>
	If you don't know what procedural noise is, I wrote a tutorial explaining it which also has links to a bunch of other better tutorials, so please take a gander!
	
	<h3>
	<a class="link" href="/archive/explaining-noise.html">Explaining Noise</a>
	</h3>
	</p>
	
	<p>
	Over the years I have accumulated and modified different noise functions I found and packaged them into two files. The first is a csharp file, 
	
	<a class="link" href="https://github.com/buckslice/turtle-quest/blob/master/Assets/Terrain/Noise.cs">Noise.cs</a>,
	
	this is what I used for the terrain, rock, and coral generation so that way I could generate the meshes once and upload it to GPU. The second file is a shader include file,
	
	<a class="link" href="https://github.com/buckslice/turtle-quest/blob/master/Assets/Shaders/Includes/Noise.cginc">Noise.cginc</a>.
	
	That's how I did all the texture effects, water refraction effect, and kelp rippling vertex displacement. So if you need your noise in a C# script use the first file, and if you need it in a shader, use the second file. Just make sure to #include "Assets/path/to/Noise.cginc" in your shaders if using the latter.
	</p>
	
	<p>
	Additionally, if you are interested in Unity's upcoming Burst compiler and ECS stuff there is a new fast math library that includes its own noise functions as well. Open Package Manager -> enable experimental packages -> Unity.Mathematics if you want to try it out!
	</p>
	
	<p>
	It's okay if you don't understand exactly what these functions do. The main way I learn is by just trying random stuff and seeing what happens. Eventually you kind of get a vague idea on what parameters to change first and you'll get faster at it. Additionally when learning it's great to test noise in shaders because you don't even have to stop the game to see the changes as shaders can recompile while the games running!
	</p>
	
	<h2>Terrain Generation</h2>
	
	<p>
	I made code that generates a grid mesh in the xz plane and then offset it on the y based on noise generation. Hopefully you read the second link about fractal brownian motion as well. Here is the fbm function.
	</p>

	<h2>Rock/Coral Generation</h2>
	
	<p>
	Talk about icospheres! vertex displacement (not in shader though)
	</p>
	
	
	<h2>Refraction Effect</h2>
	<p>
	For the underwater refraction effect, I just wrote an extra ripple function in Noise.cginc file (that all shaders were using) so at the end of their surf function they could all just add on this line to add the water refraction effect.
	</p>
	
	<pre><code class="language-csharp">o.Albedo *= ripples(IN.worldPos);</code></pre>
	
	<p>
	It is using the built in shader parameter 'worldPos' so the effect is continous over all the objects that use it. If you used regular vertex position it would've been in object space so wouldn't be continuous over the whole scene. Now here is the ripples function.
	</p>
	
	<pre><code class="language-csharp">float3 ripples(float3 wp) {
    return 0.5 + 0.5 * (worley(wp + float3(_Time.x * 7, _Time.x * 17, -_Time.x * 30), 3, .5, 0.5, 2.0, .5, 3.5));    
}</code></pre>

	<p>
	I will explain each piece of this glorious one liner ripples function. The first part '0.5 + 0.5 *' is to make the effect be lighter, because the worley noise function returns a value between 0 and 1, so this part rescales the total value to around 0.5-1.0, this is good because the ripple value is being multiplied with the albedo of all our objects and we dont want to want to make anything go full dark. 'wp' this part is providing our coordinate into the noise function which is the world position of the object. This world position is calculated in the vertex shader of all of our shaders and this is good because it makes the ripple effect look good on static and moving objects. Otherwise the ripples would still be going slow on fast moving objects and would look weird. The '+ float3(_Time...' part is basically making it so the ripples slowly scroll across all the objects, otherwise they wouldn't move at all on static objects. Each axis is just going at a different speed using the global _Time shader variable. The rest of the values are just the various parameters of the noise function to give it the right frequency/complexity/shape.
	</p>
	
	<p>	
	In hindsight it would probably be more performant to just use a scrolling light cookie texture so refraction shadows are cast via the light instead, but I wasn't sure how to make a scrolling texture through code and the ripple function was super easy to just add to every shader.
	</p>
	
	</div>
	<footer>
Copyright ©️ John F. Collins III 2019
	</footer>
	
	<script src="/libs/prism.js"></script>
  </body>
</html>
